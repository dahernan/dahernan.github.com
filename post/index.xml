<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Posts on dahernan&#39;s blog </title>
    <link>http://dahernan.github.io/post/index.xml</link>
    <language>en-US</language>
    <author>Enthusiastic Hugo User</author>
    <rights>Copyright (c) 2014, Enthusiastic Hugo User; all rights reserved.</rights>
    <updated>Wed, 03 Dec 2014 00:00:00 UTC</updated>
    
    <item>
      <title>Scrap the Web with Go</title>
      <link>http://dahernan.github.io/2014/12/03/scrap-the-web-with-go/</link>
      <pubDate>Wed, 03 Dec 2014 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2014/12/03/scrap-the-web-with-go/</guid>
      <description>&lt;p&gt;As a part of a project that I&amp;rsquo;ve been involved, I released opensource a Scraper in Go that I called &lt;a href=&#34;https://github.com/dahernan/gopherscraper&#34;&gt;gopherscraper&lt;/a&gt; is a scraper to extract information of ecommerce sites, but you can extrapolate and extract information of any website with &amp;lsquo;items&amp;rsquo;, like news, videos, and so on.&lt;/p&gt;

&lt;p&gt;The project comes with a Rest API that you can &lt;a href=&#34;https://github.com/dahernan/gopherscraper&#34;&gt;check on Github&lt;/a&gt; for more detail, and is based in CSS Selectors.
To store the items, I use Redis and ElasticSearch.&lt;/p&gt;

&lt;p&gt;Let me share a few insights in the development of the library:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;I&amp;rsquo;m using &lt;a href=&#34;https://github.com/PuerkitoBio/goquery&#34;&gt;Goquery&lt;/a&gt;, to extract information based on CSS Selectors.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The interface for scrapping is really simple just one function.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type ScrapperItems interface {
    Scrap(selector ScrapSelector) (string, chan ItemResult, error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;The interface to store the result items is also very simple. You can store the items in Redis, ElasticSearch or as a file.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type StorageItems interface {
    StoreItem(it ItemResult)
}

// store items as a File
func (sto FileStorage) StoreItem(it ItemResult) {
    if it.Err != nil {
        return
    }
    WriteJsonToDisk(sto.baseDir, it.Item)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Was easy to create a recursive Scraper, using composition, based in a normal scraper.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I started with not concurrency code at all, and after make it work, I put the go routines and waitgroups to syncronize the completion of the scraper.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func (d DefaultScrapper) Scrap(selector ScrapSelector) (string, chan ItemResult, error) {
    wg := &amp;amp;sync.WaitGroup{}
    err := validateSelector(selector)
    if err != nil {
        return &amp;quot;&amp;quot;, nil, err
    }

    items := make(chan ItemResult, bufferItemsSize)

    jobId := &amp;quot;D&amp;quot; + GenerateStringKey(selector)
    pages := paginatedUrlSelector(selector)

    wg.Add(len(pages))
    for i, _ := range pages {
        go doScrapFromUrl(jobId, pages[i], items, wg)
    }

    go closeItemsChannel(jobId, items, wg)

    return jobId, items, err
}

func doScrapFromUrl(jobId string, s ScrapSelector, items chan ItemResult, wg *sync.WaitGroup) {
    defer wg.Done()
    doc, err := fromUrl(s)
    if err != nil {
        log.Printf(&amp;quot;ERROR [%s] Scrapping %v with message %v&amp;quot;, jobId, s.Url, err.Error())
        return
    }
    DocumentScrap(jobId, s, doc, items)
}

func closeItemsChannel(jobId string, items chan ItemResult, wg *sync.WaitGroup) {
    wg.Wait()
    close(items)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;I limited the number of concurrent connections with a buffered channel.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func fromUrl(selector ScrapSelector) (*goquery.Document, error) {
    lockLimitConnections()
    defer unlockLimitConnections()

    req, err := http.NewRequest(&amp;quot;GET&amp;quot;, selector.Url, nil)
    if err != nil {
        return nil, err
    }

    req.Header.Add(&amp;quot;User-Agent&amp;quot;, defaultUserAgent)

    res, err := httpClient().Do(req)
    if err != nil {
        return nil, err
    }
    return goquery.NewDocumentFromResponse(res)
}

func UseMaxConnections(max int) {
    semaphoreMaxConnections = make(chan struct{}, max)
}

func lockLimitConnections() {
    semaphoreMaxConnections &amp;lt;- struct{}{}
}
func unlockLimitConnections() {
    &amp;lt;-semaphoreMaxConnections
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the end It was a really fun, doing what it looks like a tedious job. And I get a clean JSON document when there is not any API available to use.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Speaking at London Go Meetup</title>
      <link>http://dahernan.github.io/2014/09/10/speaking-at-london-go-meetup/</link>
      <pubDate>Wed, 10 Sep 2014 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2014/09/10/speaking-at-london-go-meetup/</guid>
      <description>&lt;p&gt;The Go London Meetup is the best place in London to learn Go and find gophers.
As part of the meetup &lt;a href=&#34;http://www.meetup.com/Go-London-User-Group/events/203467502/&#34;&gt;I gave a talk&lt;/a&gt; about Go&amp;rsquo;s Testing Ecosystem.&lt;/p&gt;

&lt;p&gt;You can get the code that I used for the examples, and the slides &lt;a href=&#34;https://github.com/dahernan/gophertest&#34;&gt;https://github.com/dahernan/gophertest&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;At the end more than a session about all testing ecosystem, I kind of live coding session about how I use &lt;a href=&#34;https://github.com/smartystreets/goconvey&#34;&gt;Goconvey&lt;/a&gt; to do testing.
So it&amp;rsquo;s a pitty that there is no video for the talk.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/gomeetup.jpeg&#34; alt=&#34;alt&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;I had good feedback, and the feeling of contribute back to the community.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Error handling and pointers in Go lang</title>
      <link>http://dahernan.github.io/2014/06/22/error-handling-and-pointers-in-go-lang/</link>
      <pubDate>Sun, 22 Jun 2014 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2014/06/22/error-handling-and-pointers-in-go-lang/</guid>
      <description>&lt;p&gt;A couple of weeks ago I went to the &lt;a href=&#34;http://www.meetup.com/Go-London-User-Group/&#34;&gt;Go London User Group&lt;/a&gt; and one of the talks was about &lt;a href=&#34;https://www.youtube.com/watch?v=Ph4eYD7Bgek&#34;&gt;error handling in Go&lt;/a&gt; by Daniel Morsing (really good talk).&lt;/p&gt;

&lt;p&gt;After thinking, I rembembered that there is another antipattern when using pointers to error, for example here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// http://play.golang.org/p/Xktu2Jz-Zc

package main

import &amp;quot;fmt&amp;quot;

type MyError struct {
    path string
    msg  string
}

func (e MyError) Error() string {
    return e.path + &amp;quot;:&amp;quot; + e.msg
}

func uglyBug(blowup bool) error {
    var err *MyError = nil
    if blowup {
        err = &amp;amp;MyError{&amp;quot;path1&amp;quot;, &amp;quot;msg1&amp;quot;}
    }
    return err
}

func main() {
    e1 := uglyBug(false)
    if e1 != nil {
        fmt.Println(&amp;quot;Pointer -&amp;gt; &amp;quot;, e1)
    } else {
        fmt.Println(&amp;quot;It&#39;s ok&amp;quot;)
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:
&lt;code&gt;
Pointer -&amp;gt;  &amp;lt;nil&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The value of &lt;em&gt;e1&lt;/em&gt; is going to be &lt;em&gt;not nil&lt;/em&gt;, because the interface is not nil (it needs to have the value and the type nil, to return nil).&lt;/p&gt;

&lt;p&gt;To fix this, you have to explicit return nil.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type MyError struct {
    path string
    msg  string
}

func (e MyError) Error() string {
    return e.path + &amp;quot;:&amp;quot; + e.msg
}

func fixed(blowup bool) error {
    if blowup {
        return &amp;amp;MyError{&amp;quot;path1&amp;quot;, &amp;quot;msg1&amp;quot;}
    }
    return nil
}

func main() {
    e1 := fixed(false)
    if e1 != nil {
        fmt.Println(&amp;quot;Pointer -&amp;gt; &amp;quot;, e1)
    } else {
        fmt.Println(&amp;quot;It&#39;s ok&amp;quot;)
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:
&lt;code&gt;
It&#39;s ok
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So always do a explicit return nil, when you need an interface to be nil.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Continuous Deployment Trends</title>
      <link>http://dahernan.github.io/2013/10/14/continuous-deployment-trends/</link>
      <pubDate>Mon, 14 Oct 2013 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2013/10/14/continuous-deployment-trends/</guid>
      <description>

&lt;p&gt;This is a post putting together what companies are doing in the Continuous Deployment space, and what are the current trends.&lt;/p&gt;

&lt;h2 id=&#34;toc_0&#34;&gt;Deployments at Etsy&lt;/h2&gt;

&lt;p&gt;Here are some data about Etsy deploys to production (only data for half of the year 2013)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Average Deploys per day: 35.75&lt;/li&gt;
&lt;li&gt;Average Authors per deploy: 7.01&lt;/li&gt;
&lt;li&gt;Average Commits per deploy: 11.25&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What we can read between lines is, if your &amp;ldquo;Average Deploys per day&amp;rdquo; is lower than 1 you&amp;rsquo;re not doing Continuous Deployment, (you probably releasing often but not doing it continuously)&lt;/p&gt;

&lt;p&gt;Some insides:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Part of the Etsy Bootcamp is to deploy code in production, on your first day.&lt;/li&gt;
&lt;li&gt;Config System / Feature Switches: You have the ability to enable a feature, for group of users, a percentage of users, or for A/B testing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The typical dev cycle is:
Deploy your feature in production ASAP -&amp;gt; Enable for QAs and Admins -&amp;gt; Public Prototype (5%-10% of users) -&amp;gt; A/B Test (50% users) -&amp;gt; Full website&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Branching in Code: Use your configuration system, to keep your feature independent, and avoid to have long live branches.&lt;/li&gt;
&lt;li&gt;Versioning: There is no versioning and no rollback, you always push forward (You can disable features if something goes wrong)&lt;/li&gt;
&lt;li&gt;Experimentation: They have a platform to manage what features are used, and when they are in production. (First they use a tool &amp;ldquo;Launch Calendar&amp;rdquo;, now more advanced unified launch management tool called &amp;ldquo;Catapult&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;Metrics: Detect if any of the changes goes wrong (statsd, ganglia, etc)&lt;/li&gt;
&lt;li&gt;Start simple &amp;gt; Deploy ASAP &amp;gt; Experiment &amp;gt; Learn&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Etsy:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.infoq.com/presentations/etsy-deploy&#34;&gt;Etsy Deploys&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://devslovebacon.com/conferences/bacon-2013/talks/bring-the-noise-continuously-deploying-under-a-hailstorm-of-metrics&#34;&gt;Etsy deployments and metrics&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Deployments at IMVU&lt;/h2&gt;

&lt;p&gt;IMVU is &amp;ldquo;the inventor&amp;rdquo; of Continuous Delivery but also leading the &amp;ldquo;Lean Startup&amp;rdquo;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Deploys per day: 50&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some insides:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The time to deploy is around 20 minutes&lt;/li&gt;
&lt;li&gt;The feedback on features is always from real customers&lt;/li&gt;
&lt;li&gt;Metrics, as an essential part of the deployments&lt;/li&gt;
&lt;li&gt;Also branching in code and feature enabled/disabled&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IMVU:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.slideshare.net/bgdurrett/sds-2010-continuous-deployment-at-imvu&#34;&gt;Continuous Deployment at IMVU&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_2&#34;&gt;Deployments at Quora&lt;/h2&gt;

&lt;p&gt;Quora is doing also well&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Deploys per day: 46&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Some insides:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;From the developer&amp;rsquo;s side, only a single command is required to push code to production: git push&lt;/li&gt;
&lt;li&gt;It takes six to seven minutes on average for a revision to start running in production.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Quora:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://engineering.quora.com/Continuous-Deployment-at-Quora&#34;&gt;Continuous Deployment at Quora&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_3&#34;&gt;How to enable Continuous Deployment&lt;/h2&gt;

&lt;p&gt;I highly recommend to watch this talk, because is a good summary of all the techniques:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.confreaks.com/videos/2365-mwrc2013-the-many-ways-to-deploy-continuously&#34;&gt;Many Ways to Deploy Continuously&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Some common patterns for devs are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Branching in Code&lt;/li&gt;
&lt;li&gt;Versioning the Database Schema&lt;/li&gt;
&lt;li&gt;Deploy to handle multiple versions at the same time (a deploy on 1000 machines could take a while, be ready to have multiple versions at the same time)&lt;/li&gt;
&lt;li&gt;Ship an image (AMIs, dokus, docker containers &amp;hellip;) isolate problems and makes your environment predictable and testable&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;toc_4&#34;&gt;Other links&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.infoq.com/presentations/Continuous-Testing-Build-Cloud&#34;&gt;Continuous Testing at Google&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://martinfowler.com/bliki/ContinuousDelivery.html&#34;&gt;Martin Fowler on Continuous Delivery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.infoq.com/articles/Continous-Delivery-Patterns&#34;&gt;Continous Delivery Patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Docker to run Elasticsearch</title>
      <link>http://dahernan.github.io/2013/08/04/docker-to-run-elasticsearch/</link>
      <pubDate>Sun, 04 Aug 2013 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2013/08/04/docker-to-run-elasticsearch/</guid>
      <description>&lt;p&gt;In this post I&amp;rsquo;m going to explain how to create and use a docker image, for easy access to &lt;a href=&#34;http://www.elasticsearch.org&#34;&gt;elasticsearch&lt;/a&gt; for development purposes.
If you don&amp;rsquo;t know &lt;a href=&#34;http://docker.io/&#34;&gt;docker&lt;/a&gt;, just check it out. In my opinion is the way that everybody is going to distribuite webapps soon.&lt;/p&gt;

&lt;p&gt;In the same way that the project has library dependencies, your app usually depends on more things. Let&amp;rsquo;s say the database or in this case the search engine.
Why not distribute the dependency with the code? Well even if you have a VM could be to much.&lt;/p&gt;

&lt;p&gt;With containers that is over, now you can distribute with your source a Dockerfile, or even &lt;a href=&#34;http://blog.docker.io/2013/07/how-to-use-your-own-registry/&#34;&gt;have yor own repository of docker images&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For my dependency &lt;a href=&#34;http://www.elasticsearch.org&#34;&gt;elasticsearch&lt;/a&gt; a need a new Dockerfile, so the next developer could reproduce my environment very easy.&lt;/p&gt;

&lt;p&gt;So this is the content of my &lt;em&gt;Dockerfile&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gist.github.com/dahernan/6149626&#34;&gt;https://gist.github.com/dahernan/6149626&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now I can build the image with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker build -t=&amp;quot;elasticsearch&amp;quot; .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And after a while if I do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker images

REPOSITORY          TAG                 ID                  CREATED             SIZE
ubuntu              12.04               8dbd9e392a96        3 months ago        131.5 MB (virtual 131.5 MB)
ubuntu              12.10               b750fe79269d        4 months ago        24.65 kB (virtual 180.1 MB)
ubuntu              latest              8dbd9e392a96        3 months ago        131.5 MB (virtual 131.5 MB)
ubuntu              precise             8dbd9e392a96        3 months ago        131.5 MB (virtual 131.5 MB)
ubuntu              quantal             b750fe79269d        4 months ago        24.65 kB (virtual 180.1 MB)
elasticsearch       latest              ef2487bb289d        52 seconds ago      12.29 kB (virtual 558.7 MB)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I can see my new image &lt;em&gt;elasticsearch&lt;/em&gt; there, and finally I can run elasticsearch in that container.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run -d elasticsearch

$ docker ps
ID                  IMAGE                  COMMAND                CREATED             STATUS              PORTS
29fd16250848        elasticsearch:latest   /bin/sh -c elasticse   32 seconds ago      Up 32 seconds       9200-&amp;gt;9200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now my elasticsearch instance is running in its own container, forwarding the port 9200. So if I want to try to run a elasticsearch cluster, I&amp;rsquo;m only have to run more containers.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Compile and reload your package in Go lang</title>
      <link>http://dahernan.github.io/2013/08/03/compile-and-reload-your-package-in-go-lang/</link>
      <pubDate>Sat, 03 Aug 2013 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2013/08/03/compile-and-reload-your-package-in-go-lang/</guid>
      <description>&lt;p&gt;One of the Go lang goodness is the blazing fast compiler (can you hear me Scala? :P), that can give you the productivity of a interpreted language.
But to be, productive in the same way, at least building Web services, you need get rid of the recompile and kill/reload cycle for your application.&lt;/p&gt;

&lt;p&gt;I tried a couple of utils to do that, and the most simple that it works is &lt;a href=&#34;https://github.com/skelterjohn/rerun&#34;&gt;&lt;em&gt;rerun&lt;/em&gt;&lt;/a&gt;
You can just clone the repository, do a &amp;lsquo;go install&amp;rsquo; and add the binary to your PATH variable.&lt;/p&gt;

&lt;p&gt;And now with a simple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rerun --test github.com/dahernan/goangular/server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have my webserver running, and every time that I make a change in the code, the test are passed again, and the server is reload. I know, right now my server It&amp;rsquo;s very light and It does that in milliseconds, but I&amp;rsquo;m sure it&amp;rsquo;s not going to reach the start time of any Java application :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Json service in Go lang</title>
      <link>http://dahernan.github.io/2013/06/21/json-service-in-go-lang/</link>
      <pubDate>Fri, 21 Jun 2013 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2013/06/21/json-service-in-go-lang/</guid>
      <description>&lt;p&gt;These days I&amp;rsquo;m experimenting with Go lang, I love the language. I like specially the simplicity, you can check out
the principles of design, in the presentation from Rob Pike, &lt;a href=&#34;http://www.stanford.edu/class/ee380/Abstracts/100428-pike-stanford.pdf&#34;&gt;Another Go At Language Design&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So, my first try in Go is to do a small Rest API for serving JSON documents. Also try a little TDD in Go to see how easy it could be.&lt;/p&gt;

&lt;p&gt;On the test it&amp;rsquo;s easy to mock whatever you need, because function are first class citizens,
so you can have implementations on fly. And some of the clasess of the standard library they have test utilities like &amp;lsquo;httptest&amp;rsquo;&lt;/p&gt;

&lt;p&gt;Here the test.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
  &amp;quot;github.com/bmizerany/assert&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;net/http/httptest&amp;quot;
    &amp;quot;testing&amp;quot;
)

func TestJsonServerReturnsJsonDocumentWithRightHeaders(t *testing.T) {

    req := new(http.Request)

    builder := func(req *http.Request) interface{} {
        return map[string]interface{}{
            &amp;quot;test&amp;quot;: &amp;quot;test_value&amp;quot;,
        }
    }

    jsonServer := JsonServer(builder)
    responseWriter := httptest.NewRecorder()

    // call to test
    jsonServer(responseWriter, req)

    contentType := responseWriter.Header().Get(&amp;quot;Content-Type&amp;quot;)
    assert.Equal(t, contentType, &amp;quot;application/json&amp;quot;)

    assert.Equal(t, &amp;quot;{\&amp;quot;test\&amp;quot;:\&amp;quot;test_value\&amp;quot;}\n&amp;quot;, responseWriter.Body.String())

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now the implementation, with a little functional style.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
  &amp;quot;encoding/json&amp;quot;
  &amp;quot;github.com/bmizerany/pat&amp;quot;
  &amp;quot;log&amp;quot;
    &amp;quot;net/http&amp;quot;
)

type httpHandlerFunc func(w http.ResponseWriter, req *http.Request)
type jsonHttpBuilderFunc func(req *http.Request) interface{}

func JsonBuilder(req *http.Request) interface{} {
    jsonMap := make(map[string]interface{})
    name := req.URL.Query().Get(&amp;quot;:name&amp;quot;)
    jsonMap[&amp;quot;message&amp;quot;] = &amp;quot;hello &amp;quot; + name
    return jsonMap
}

func JsonServer(builderFunc jsonHttpBuilderFunc) (hanlderFunc httpHandlerFunc) {
    hanlderFunc = func(w http.ResponseWriter, req *http.Request) {
        enc := json.NewEncoder(w)
        jsonMap := builderFunc(req)
        w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
        if err := enc.Encode(&amp;amp;jsonMap); err != nil {
            log.Fatal(err)
        }
    }
    return
}

func main() {
    m := pat.New()
    m.Get(&amp;quot;/api/hello/:name&amp;quot;, http.HandlerFunc(JsonServer(JsonBuilder)))

    http.Handle(&amp;quot;/&amp;quot;, m)
    err := http.ListenAndServe(&amp;quot;:3000&amp;quot;, nil)
    if err != nil {
        log.Fatal(&amp;quot;ListenAndServe: &amp;quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>http://dahernan.github.io/2013/06/14/introduction/</link>
      <pubDate>Fri, 14 Jun 2013 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2013/06/14/introduction/</guid>
      <description>&lt;p&gt;Maybe you remember me from other old blogs, like &lt;a href=&#34;https://dahernan.blogspot.com&#34;&gt;dahernan.blogspot.com&lt;/a&gt;, so I&amp;rsquo;m going to try to start again,
and post whatever thing I think is relevant, in this tech world.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>