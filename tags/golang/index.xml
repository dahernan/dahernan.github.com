<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Golang on dahernan&#39;s blog </title>
    <link>http://dahernan.github.io/tags/golang/index.xml</link>
    <language>en-US</language>
    <author>Enthusiastic Hugo User</author>
    <rights>Copyright (c) 2014, Enthusiastic Hugo User; all rights reserved.</rights>
    <updated>Wed, 04 Feb 2015 00:00:00 UTC</updated>
    
    <item>
      <title>Context and Cancellation of goroutines</title>
      <link>http://dahernan.github.io/2015/02/04/context-and-cancellation-of-goroutines/</link>
      <pubDate>Wed, 04 Feb 2015 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2015/02/04/context-and-cancellation-of-goroutines/</guid>
      <description>&lt;p&gt;Yesterday I went to the event London Go Gathering, where all the talks had a great level, but particulary &lt;a href=&#34;https://twitter.com/peterbourgon&#34;&gt;Peter Bourgon&lt;/a&gt; gave me idea to write about the excelent package &lt;a href=&#34;http://blog.golang.org/context&#34;&gt;context&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Context is used to pass request scoped variables, but in this case I&amp;rsquo;m only going to focus in cancelation signals.&lt;/p&gt;

&lt;p&gt;Lets say that I have a program that execute a long running function, in this case &lt;code&gt;work&lt;/code&gt; and we run it in a separate go routine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;sync&amp;quot;
    &amp;quot;time&amp;quot;

)

var (
    wg sync.WaitGroup
)

func work() error {
    defer wg.Done()

    for i := 0; i &amp;lt; 1000; i++ {
        select {
        case &amp;lt;-time.After(2 * time.Second):
            fmt.Println(&amp;quot;Doing some work &amp;quot;, i)
        }
    }
    return nil
}


func main() {
    fmt.Println(&amp;quot;Hey, I&#39;m going to do some work&amp;quot;)

    wg.Add(1)
    go work()
    wg.Wait()

    fmt.Println(&amp;quot;Finished. I&#39;m going home&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run work.go
Hey, I&#39;m going to do some work
Doing some work  0
Doing some work  1
Doing some work  2
Doing some work  3
...
Doing some work  999
Finished. I&#39;m going home
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now imagine that we have to call that &lt;code&gt;work&lt;/code&gt; function from a user interaction or a http request, we probably don&amp;rsquo;t want to wait forever for that goroutine to finish, so a common pattern is to set a timeout, using a buffered channel, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;time&amp;quot;
)

func work() error {
    for i := 0; i &amp;lt; 1000; i++ {
        select {
        case &amp;lt;-time.After(2 * time.Second):
            fmt.Println(&amp;quot;Doing some work &amp;quot;, i)
        }
    }
    return nil
}

func main() {
    fmt.Println(&amp;quot;Hey, I&#39;m going to do some work&amp;quot;)

    ch := make(chan error, 1)
    go func() {
        ch &amp;lt;- work()
    }()

    select {
    case err := &amp;lt;-ch:
        if err != nil {
            log.Fatal(&amp;quot;Something went wrong :(&amp;quot;, err)
        }
    case &amp;lt;-time.After(4 * time.Second):
        fmt.Println(&amp;quot;Life is to short to wait that long&amp;quot;)
    }

    fmt.Println(&amp;quot;Finished. I&#39;m going home&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run work.go
Hey, I&#39;m going to do some work
Doing some work  0
Doing some work  1
Life is to short to wait that long
Finished. I&#39;m going home
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, is a little bit better because, the main execution doesn&amp;rsquo;t have to wait for &lt;code&gt;work&lt;/code&gt; if it&amp;rsquo;s timing out.&lt;/p&gt;

&lt;p&gt;But it has a problem, if my program is still running like for example a web server, even if I don&amp;rsquo;t wait for the function &lt;code&gt;work&lt;/code&gt; to finish, the goroutine it would be running and consuming resources. So I need a way to cancel that goroutine.&lt;/p&gt;

&lt;p&gt;For cancelation of the goroutine we can use the context package. We have to change the function to accept an argument of type &lt;code&gt;context.Context&lt;/code&gt;, by convention it&amp;rsquo;s usuallly the first argument.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;sync&amp;quot;
    &amp;quot;time&amp;quot;

    &amp;quot;golang.org/x/net/context&amp;quot;
)

var (
    wg sync.WaitGroup
)

func work(ctx context.Context) error {
    defer wg.Done()

    for i := 0; i &amp;lt; 1000; i++ {
        select {
        case &amp;lt;-time.After(2 * time.Second):
            fmt.Println(&amp;quot;Doing some work &amp;quot;, i)

        // we received the signal of cancelation in this channel    
        case &amp;lt;-ctx.Done():
            fmt.Println(&amp;quot;Cancel the context &amp;quot;, i)
            return ctx.Err()
        }
    }
    return nil
}

func main() {   
    ctx, cancel := context.WithTimeout(context.Background(), 4*time.Second)
    defer cancel()

    fmt.Println(&amp;quot;Hey, I&#39;m going to do some work&amp;quot;)

    wg.Add(1)
    go work(ctx)
    wg.Wait()

    fmt.Println(&amp;quot;Finished. I&#39;m going home&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run work.go
Hey, I&#39;m going to do some work
Doing some work  0
Cancel the context  1
Finished. I&#39;m going home
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty good!, apart that the code looks more simple to manage the timeout, now we are making sure that the function &lt;code&gt;work&lt;/code&gt; doesn&amp;rsquo;t waste any resource.&lt;/p&gt;

&lt;p&gt;These examples are good to learn the basics, but let&amp;rsquo;s try to make it more real.
Now the &lt;code&gt;work&lt;/code&gt; function is going to do an http request to a server and the server is going to be this other program:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

// Lazy and Very Random Server 
import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;math/rand&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;time&amp;quot;
)

func main() {
    http.HandleFunc(&amp;quot;/&amp;quot;, LazyServer)
    http.ListenAndServe(&amp;quot;:1111&amp;quot;, nil)
}

// sometimes really fast server, sometimes really slow server
func LazyServer(w http.ResponseWriter, req *http.Request) {
    headOrTails := rand.Intn(2)

    if headOrTails == 0 {
        time.Sleep(6 * time.Second)
        fmt.Fprintf(w, &amp;quot;Go! slow %v&amp;quot;, headOrTails)
        fmt.Printf(&amp;quot;Go! slow %v&amp;quot;, headOrTails)
        return
    }

    fmt.Fprintf(w, &amp;quot;Go! quick %v&amp;quot;, headOrTails)
    fmt.Printf(&amp;quot;Go! quick %v&amp;quot;, headOrTails)
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Randomly is going to be very quick or very slow, we can check that with &lt;code&gt;curl&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl http://localhost:1111/
Go! quick 1
$ curl http://localhost:1111/
Go! quick 1
$ curl http://localhost:1111/
*some seconds later*
Go! slow 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we are going to make an http request to this server, in a goroutine, but if the server is slow we are going to Cancel the request and return quickly, so we can manage the cancellation and free the connection.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;sync&amp;quot;
    &amp;quot;time&amp;quot;

    &amp;quot;golang.org/x/net/context&amp;quot;
)

var (
    wg sync.WaitGroup
)

// main is not changed
func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    fmt.Println(&amp;quot;Hey, I&#39;m going to do some work&amp;quot;)

    wg.Add(1)
    go work(ctx)
    wg.Wait()

    fmt.Println(&amp;quot;Finished. I&#39;m going home&amp;quot;)

}

func work(ctx context.Context) error {
    defer wg.Done()

    tr := &amp;amp;http.Transport{}
    client := &amp;amp;http.Client{Transport: tr}

    // anonymous struct to pack and unpack data in the channel
    c := make(chan struct {
        r   *http.Response
        err error
    }, 1)

    req, _ := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;http://localhost:1111&amp;quot;, nil)
    go func() {
        resp, err := client.Do(req)
        fmt.Println(&amp;quot;Doing http request is a hard job&amp;quot;)
        pack := struct {
            r   *http.Response
            err error
        }{resp, err}
        c &amp;lt;- pack
    }()

    select {
    case &amp;lt;-ctx.Done():
        tr.CancelRequest(req)
        &amp;lt;-c // Wait for client.Do
        fmt.Println(&amp;quot;Cancel the context&amp;quot;)
        return ctx.Err()
    case ok := &amp;lt;-c:
        err := ok.err
        resp := ok.r
        if err != nil {
            fmt.Println(&amp;quot;Error &amp;quot;, err)
            return err
        }

        defer resp.Body.Close()
        out, _ := ioutil.ReadAll(resp.Body)
        fmt.Printf(&amp;quot;Server Response: %s\n&amp;quot;, out)

    }
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run work.go
Hey, I&#39;m going to do some work
Doing http request is a hard job
Server Response: Go! quick 1
Finished. I&#39;m going home

$ go run work.go
Hey, I&#39;m going to do some work
Doing http request is a hard job
Cancel the context
Finished. I&#39;m going home
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see in the output, we avoid the slow responses from the server.&lt;/p&gt;

&lt;p&gt;In the client the tcp connection is canceled so is not going to be busy waiting for a slow response, so we don&amp;rsquo;t waste resources.&lt;/p&gt;

&lt;p&gt;Happy coding gophers!.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker image for Go service from the Scratch</title>
      <link>http://dahernan.github.io/2014/12/09/docker-image-for-go-service-from-the-scratch/</link>
      <pubDate>Tue, 09 Dec 2014 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2014/12/09/docker-image-for-go-service-from-the-scratch/</guid>
      <description>

&lt;p&gt;Today I changed the script to dockerize go projects &lt;a href=&#34;https://github.com/dahernan/godockerize&#34;&gt;godockerize&lt;/a&gt;, to support the &amp;lsquo;scratch&amp;rsquo; image.&lt;/p&gt;

&lt;p&gt;The way I do it, is cross compile for Linux, and after that add the binary to the image, that&amp;rsquo;s all. Ready to build and run.&lt;/p&gt;

&lt;h3 id=&#34;toc_0&#34;&gt;To enable cross compile on Mac to build Linux executable&lt;/h3&gt;

&lt;p&gt;Follow this steps&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /usr/local/go/src

$ sudo GOOS=linux CGO_ENABLED=0 ./make.bash --no-clean

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can try it doing, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ GOOS=linux CGO_ENABLED=0 go build -o gopherscraper

# Checking that is linux binary
$ file gopherscraper
gopherscraper: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;toc_1&#34;&gt;Use the new flag &amp;lsquo;scratch&amp;rsquo;&lt;/h2&gt;

&lt;p&gt;Once you activate cross compilation you can use the new flag to generate and build the Docker image from the &amp;lsquo;scratch&amp;rsquo;&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd $GOPATH/src/github.com/dahernan/gopherscraper

# Run godockerize using -scratch
$ godockerize -expose 3001 -scratch

Dockerfile generated, you can build the image with:
$ docker build -t gopherscraper .


# Run my microservice
$ docker run --rm  -p 3001:3001 -e ES=192.168.1.101 gopherscraper

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can get a really light image, using this method :)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;REPOSITORY                    TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
gopherscraper                 latest              8dad2e0ca7f9        55 minutes ago      10.61 MB
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Generate a Dockerfile for Go Microservice</title>
      <link>http://dahernan.github.io/2014/12/05/generate-a-dockerfile-for-go-microservice/</link>
      <pubDate>Fri, 05 Dec 2014 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2014/12/05/generate-a-dockerfile-for-go-microservice/</guid>
      <description>

&lt;p&gt;As part of doing a few Go REST Services, for every project I usually put a Dockerfile to compile an run the project in a Docker container.
The Dockerfile it&amp;rsquo;s always the same, just change it the project name, and I&amp;rsquo;m using &lt;a href=&#34;https://github.com/tools/godep&#34;&gt;godep&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So in DRY spirit a did a Minimal Viable Script to generate the Dockerfile for me, the project is in Github and I called &lt;a href=&#34;https://github.com/dahernan/godockerize&#34;&gt;godockerize&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The Dockerfile is based in the golang image, it follows these steps.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Based in golang:stable&lt;/li&gt;
&lt;li&gt;Use &lt;a href=&#34;https://github.com/tools/godep&#34;&gt;godep&lt;/a&gt; for vendoring the dependencies. (if you are not using godep, It will break).&lt;/li&gt;
&lt;li&gt;Uses the project name and the root directory as a ENTRYPOINT&lt;/li&gt;
&lt;li&gt;Restores the dependencies via &amp;lsquo;godep restore&amp;rsquo;&lt;/li&gt;
&lt;li&gt;Compiles the project&lt;/li&gt;
&lt;li&gt;Exposes the port&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Is inspired by this two blog post.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.charmes.net/2014/11/release-go-code-and-others-via-docker.html&#34;&gt;http://blog.charmes.net/2014/11/release-go-code-and-others-via-docker.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.golang.org/docker&#34;&gt;https://blog.golang.org/docker&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;toc_0&#34;&gt;Install godockerize&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/dahernan/godockerize

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_1&#34;&gt;Usage Example&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# Go to the root directory of your project, for example
$ cd $GOPATH/src/github.com/dahernan/gopherscraper


# Run godockerize exposing the port 3001
$ godockerize -expose 3001

Dockerfile generated, you can build the image with:
$ docker build -t gopherscraper .

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;toc_2&#34;&gt;Run my microservice&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --rm  -p 3001:3001 -e ES=192.168.1.101 gopherscraper

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Scrap the Web with Go</title>
      <link>http://dahernan.github.io/2014/12/03/scrap-the-web-with-go/</link>
      <pubDate>Wed, 03 Dec 2014 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2014/12/03/scrap-the-web-with-go/</guid>
      <description>&lt;p&gt;As a part of a project that I&amp;rsquo;ve been involved, I released opensource a Scraper in Go that I called &lt;a href=&#34;https://github.com/dahernan/gopherscraper&#34;&gt;gopherscraper&lt;/a&gt; is a scraper to extract information of ecommerce sites, but you can extrapolate and extract information of any website with &amp;lsquo;items&amp;rsquo;, like news, videos, and so on.&lt;/p&gt;

&lt;p&gt;The project comes with a Rest API that you can &lt;a href=&#34;https://github.com/dahernan/gopherscraper&#34;&gt;check on Github&lt;/a&gt; for more detail, and is based in CSS Selectors.
To store the items, I use Redis and ElasticSearch.&lt;/p&gt;

&lt;p&gt;Let me share a few insights in the development of the library:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;I&amp;rsquo;m using &lt;a href=&#34;https://github.com/PuerkitoBio/goquery&#34;&gt;Goquery&lt;/a&gt;, to extract information based on CSS Selectors.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The interface for scrapping is really simple just one function.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type ScrapperItems interface {
    Scrap(selector ScrapSelector) (string, chan ItemResult, error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;The interface to store the result items is also very simple. You can store the items in Redis, ElasticSearch or as a file.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type StorageItems interface {
    StoreItem(it ItemResult)
}

// store items as a File
func (sto FileStorage) StoreItem(it ItemResult) {
    if it.Err != nil {
        return
    }
    WriteJsonToDisk(sto.baseDir, it.Item)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Was easy to create a recursive Scraper, using composition, based in a normal scraper.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I started with not concurrency code at all, and after make it work, I put the go routines and waitgroups to syncronize the completion of the scraper.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func (d DefaultScrapper) Scrap(selector ScrapSelector) (string, chan ItemResult, error) {
    wg := &amp;amp;sync.WaitGroup{}
    err := validateSelector(selector)
    if err != nil {
        return &amp;quot;&amp;quot;, nil, err
    }

    items := make(chan ItemResult, bufferItemsSize)

    jobId := &amp;quot;D&amp;quot; + GenerateStringKey(selector)
    pages := paginatedUrlSelector(selector)

    wg.Add(len(pages))
    for i, _ := range pages {
        go doScrapFromUrl(jobId, pages[i], items, wg)
    }

    go closeItemsChannel(jobId, items, wg)

    return jobId, items, err
}

func doScrapFromUrl(jobId string, s ScrapSelector, items chan ItemResult, wg *sync.WaitGroup) {
    defer wg.Done()
    doc, err := fromUrl(s)
    if err != nil {
        log.Printf(&amp;quot;ERROR [%s] Scrapping %v with message %v&amp;quot;, jobId, s.Url, err.Error())
        return
    }
    DocumentScrap(jobId, s, doc, items)
}

func closeItemsChannel(jobId string, items chan ItemResult, wg *sync.WaitGroup) {
    wg.Wait()
    close(items)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;I limited the number of concurrent connections with a buffered channel.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func fromUrl(selector ScrapSelector) (*goquery.Document, error) {
    lockLimitConnections()
    defer unlockLimitConnections()

    req, err := http.NewRequest(&amp;quot;GET&amp;quot;, selector.Url, nil)
    if err != nil {
        return nil, err
    }

    req.Header.Add(&amp;quot;User-Agent&amp;quot;, defaultUserAgent)

    res, err := httpClient().Do(req)
    if err != nil {
        return nil, err
    }
    return goquery.NewDocumentFromResponse(res)
}

func UseMaxConnections(max int) {
    semaphoreMaxConnections = make(chan struct{}, max)
}

func lockLimitConnections() {
    semaphoreMaxConnections &amp;lt;- struct{}{}
}
func unlockLimitConnections() {
    &amp;lt;-semaphoreMaxConnections
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the end It was a really fun, doing what it looks like a tedious job. And I get a clean JSON document when there is not any API available to use.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Speaking at London Go Meetup</title>
      <link>http://dahernan.github.io/2014/09/10/speaking-at-london-go-meetup/</link>
      <pubDate>Wed, 10 Sep 2014 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2014/09/10/speaking-at-london-go-meetup/</guid>
      <description>&lt;p&gt;The Go London Meetup is the best place in London to learn Go and find gophers.
As part of the meetup &lt;a href=&#34;http://www.meetup.com/Go-London-User-Group/events/203467502/&#34;&gt;I gave a talk&lt;/a&gt; about Go&amp;rsquo;s Testing Ecosystem.&lt;/p&gt;

&lt;p&gt;You can get the code that I used for the examples, and the slides &lt;a href=&#34;https://github.com/dahernan/gophertest&#34;&gt;https://github.com/dahernan/gophertest&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;At the end more than a session about all testing ecosystem, was a kind of live coding session about how I use &lt;a href=&#34;https://github.com/smartystreets/goconvey&#34;&gt;Goconvey&lt;/a&gt; to do testing.
So it&amp;rsquo;s a pitty that there is no video for the talk, because the slides and the code is not very representative.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/gomeetup.jpeg&#34; alt=&#34;alt&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;I had good feedback, and the feeling of contribute back to the community.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Error handling and pointers in Go lang</title>
      <link>http://dahernan.github.io/2014/06/22/error-handling-and-pointers-in-go-lang/</link>
      <pubDate>Sun, 22 Jun 2014 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2014/06/22/error-handling-and-pointers-in-go-lang/</guid>
      <description>&lt;p&gt;A couple of weeks ago I went to the &lt;a href=&#34;http://www.meetup.com/Go-London-User-Group/&#34;&gt;Go London User Group&lt;/a&gt; and one of the talks was about &lt;a href=&#34;https://www.youtube.com/watch?v=Ph4eYD7Bgek&#34;&gt;error handling in Go&lt;/a&gt; by Daniel Morsing (really good talk).&lt;/p&gt;

&lt;p&gt;After thinking, I rembembered that there is another antipattern when using pointers to error, for example here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// http://play.golang.org/p/Xktu2Jz-Zc

package main

import &amp;quot;fmt&amp;quot;

type MyError struct {
    path string
    msg  string
}

func (e MyError) Error() string {
    return e.path + &amp;quot;:&amp;quot; + e.msg
}

func uglyBug(blowup bool) error {
    var err *MyError = nil
    if blowup {
        err = &amp;amp;MyError{&amp;quot;path1&amp;quot;, &amp;quot;msg1&amp;quot;}
    }
    return err
}

func main() {
    e1 := uglyBug(false)
    if e1 != nil {
        fmt.Println(&amp;quot;Pointer -&amp;gt; &amp;quot;, e1)
    } else {
        fmt.Println(&amp;quot;It&#39;s ok&amp;quot;)
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:
&lt;code&gt;
Pointer -&amp;gt;  &amp;lt;nil&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The value of &lt;em&gt;e1&lt;/em&gt; is going to be &lt;em&gt;not nil&lt;/em&gt;, because the interface is not nil (it needs to have the value and the type nil, to return nil).&lt;/p&gt;

&lt;p&gt;To fix this, you have to explicit return nil.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type MyError struct {
    path string
    msg  string
}

func (e MyError) Error() string {
    return e.path + &amp;quot;:&amp;quot; + e.msg
}

func fixed(blowup bool) error {
    if blowup {
        return &amp;amp;MyError{&amp;quot;path1&amp;quot;, &amp;quot;msg1&amp;quot;}
    }
    return nil
}

func main() {
    e1 := fixed(false)
    if e1 != nil {
        fmt.Println(&amp;quot;Pointer -&amp;gt; &amp;quot;, e1)
    } else {
        fmt.Println(&amp;quot;It&#39;s ok&amp;quot;)
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:
&lt;code&gt;
It&#39;s ok
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So always do a explicit return nil, when you need an interface to be nil.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Compile and reload your package in Go lang</title>
      <link>http://dahernan.github.io/2013/08/03/compile-and-reload-your-package-in-go-lang/</link>
      <pubDate>Sat, 03 Aug 2013 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2013/08/03/compile-and-reload-your-package-in-go-lang/</guid>
      <description>&lt;p&gt;One of the Go lang goodness is the blazing fast compiler (can you hear me Scala? :P), that can give you the productivity of a interpreted language.
But to be, productive in the same way, at least building Web services, you need get rid of the recompile and kill/reload cycle for your application.&lt;/p&gt;

&lt;p&gt;I tried a couple of utils to do that, and the most simple that it works is &lt;a href=&#34;https://github.com/skelterjohn/rerun&#34;&gt;&lt;em&gt;rerun&lt;/em&gt;&lt;/a&gt;
You can just clone the repository, do a &amp;lsquo;go install&amp;rsquo; and add the binary to your PATH variable.&lt;/p&gt;

&lt;p&gt;And now with a simple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rerun --test github.com/dahernan/goangular/server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have my webserver running, and every time that I make a change in the code, the test are passed again, and the server is reload. I know, right now my server It&amp;rsquo;s very light and It does that in milliseconds, but I&amp;rsquo;m sure it&amp;rsquo;s not going to reach the start time of any Java application :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Json service in Go lang</title>
      <link>http://dahernan.github.io/2013/06/21/json-service-in-go-lang/</link>
      <pubDate>Fri, 21 Jun 2013 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2013/06/21/json-service-in-go-lang/</guid>
      <description>&lt;p&gt;These days I&amp;rsquo;m experimenting with Go lang, I love the language. I like specially the simplicity, you can check out
the principles of design, in the presentation from Rob Pike, &lt;a href=&#34;http://www.stanford.edu/class/ee380/Abstracts/100428-pike-stanford.pdf&#34;&gt;Another Go At Language Design&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So, my first try in Go is to do a small Rest API for serving JSON documents. Also try a little TDD in Go to see how easy it could be.&lt;/p&gt;

&lt;p&gt;On the test it&amp;rsquo;s easy to mock whatever you need, because function are first class citizens,
so you can have implementations on fly. And some of the clasess of the standard library they have test utilities like &amp;lsquo;httptest&amp;rsquo;&lt;/p&gt;

&lt;p&gt;Here the test.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
  &amp;quot;github.com/bmizerany/assert&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;net/http/httptest&amp;quot;
    &amp;quot;testing&amp;quot;
)

func TestJsonServerReturnsJsonDocumentWithRightHeaders(t *testing.T) {

    req := new(http.Request)

    builder := func(req *http.Request) interface{} {
        return map[string]interface{}{
            &amp;quot;test&amp;quot;: &amp;quot;test_value&amp;quot;,
        }
    }

    jsonServer := JsonServer(builder)
    responseWriter := httptest.NewRecorder()

    // call to test
    jsonServer(responseWriter, req)

    contentType := responseWriter.Header().Get(&amp;quot;Content-Type&amp;quot;)
    assert.Equal(t, contentType, &amp;quot;application/json&amp;quot;)

    assert.Equal(t, &amp;quot;{\&amp;quot;test\&amp;quot;:\&amp;quot;test_value\&amp;quot;}\n&amp;quot;, responseWriter.Body.String())

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now the implementation, with a little functional style.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
  &amp;quot;encoding/json&amp;quot;
  &amp;quot;github.com/bmizerany/pat&amp;quot;
  &amp;quot;log&amp;quot;
    &amp;quot;net/http&amp;quot;
)

type httpHandlerFunc func(w http.ResponseWriter, req *http.Request)
type jsonHttpBuilderFunc func(req *http.Request) interface{}

func JsonBuilder(req *http.Request) interface{} {
    jsonMap := make(map[string]interface{})
    name := req.URL.Query().Get(&amp;quot;:name&amp;quot;)
    jsonMap[&amp;quot;message&amp;quot;] = &amp;quot;hello &amp;quot; + name
    return jsonMap
}

func JsonServer(builderFunc jsonHttpBuilderFunc) (hanlderFunc httpHandlerFunc) {
    hanlderFunc = func(w http.ResponseWriter, req *http.Request) {
        enc := json.NewEncoder(w)
        jsonMap := builderFunc(req)
        w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
        if err := enc.Encode(&amp;amp;jsonMap); err != nil {
            log.Fatal(err)
        }
    }
    return
}

func main() {
    m := pat.New()
    m.Get(&amp;quot;/api/hello/:name&amp;quot;, http.HandlerFunc(JsonServer(JsonBuilder)))

    http.Handle(&amp;quot;/&amp;quot;, m)
    err := http.ListenAndServe(&amp;quot;:3000&amp;quot;, nil)
    if err != nil {
        log.Fatal(&amp;quot;ListenAndServe: &amp;quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>