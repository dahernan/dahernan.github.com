<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Golang on dahernan&#39;s blog </title>
    <link>http://dahernan.github.io/tags/golang/index.xml</link>
    <language>en-US</language>
    <author>Enthusiastic Hugo User</author>
    <rights>Copyright (c) 2014, Enthusiastic Hugo User; all rights reserved.</rights>
    <updated>Wed, 03 Dec 2014 00:00:00 UTC</updated>
    
    <item>
      <title>Scrap the Web with Go</title>
      <link>http://dahernan.github.io/2014/12/03/scrap-the-web-with-go/</link>
      <pubDate>Wed, 03 Dec 2014 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2014/12/03/scrap-the-web-with-go/</guid>
      <description>&lt;p&gt;As a part of a project that I&amp;rsquo;ve been involved, I released opensource a Scraper in Go that I called &lt;a href=&#34;https://github.com/dahernan/gopherscraper&#34;&gt;gopherscraper&lt;/a&gt; is a scraper to extract information of ecommerce sites, but you can extrapolate and extract information of any website with &amp;lsquo;items&amp;rsquo;, like news, videos, and so on.&lt;/p&gt;

&lt;p&gt;The project comes with a Rest API that you can &lt;a href=&#34;https://github.com/dahernan/gopherscraper&#34;&gt;check on Github&lt;/a&gt; for more detail, and is based in CSS Selectors.
To store the items, I use Redis and ElasticSearch.&lt;/p&gt;

&lt;p&gt;Let me share a few insights in the development of the library:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;I&amp;rsquo;m using &lt;a href=&#34;https://github.com/PuerkitoBio/goquery&#34;&gt;Goquery&lt;/a&gt;, to extract information based on CSS Selectors.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The interface for scrapping is really simple just one function.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type ScrapperItems interface {
    Scrap(selector ScrapSelector) (string, chan ItemResult, error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;The interface to store the result items is also very simple. You can store the items in Redis, ElasticSearch or as a file.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type StorageItems interface {
    StoreItem(it ItemResult)
}

// store items as a File
func (sto FileStorage) StoreItem(it ItemResult) {
    if it.Err != nil {
        return
    }
    WriteJsonToDisk(sto.baseDir, it.Item)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Was easy to create a recursive Scraper, using composition, based in a normal scraper.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;I started with not concurrency code at all, and after make it work, I put the go routines and waitgroups to syncronize the completion of the scraper.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func (d DefaultScrapper) Scrap(selector ScrapSelector) (string, chan ItemResult, error) {
    wg := &amp;amp;sync.WaitGroup{}
    err := validateSelector(selector)
    if err != nil {
        return &amp;quot;&amp;quot;, nil, err
    }

    items := make(chan ItemResult, bufferItemsSize)

    jobId := &amp;quot;D&amp;quot; + GenerateStringKey(selector)
    pages := paginatedUrlSelector(selector)

    wg.Add(len(pages))
    for i, _ := range pages {
        go doScrapFromUrl(jobId, pages[i], items, wg)
    }

    go closeItemsChannel(jobId, items, wg)

    return jobId, items, err
}

func doScrapFromUrl(jobId string, s ScrapSelector, items chan ItemResult, wg *sync.WaitGroup) {
    defer wg.Done()
    doc, err := fromUrl(s)
    if err != nil {
        log.Printf(&amp;quot;ERROR [%s] Scrapping %v with message %v&amp;quot;, jobId, s.Url, err.Error())
        return
    }
    DocumentScrap(jobId, s, doc, items)
}

func closeItemsChannel(jobId string, items chan ItemResult, wg *sync.WaitGroup) {
    wg.Wait()
    close(items)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;I limited the number of concurrent connections with a buffered channel.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func fromUrl(selector ScrapSelector) (*goquery.Document, error) {
    lockLimitConnections()
    defer unlockLimitConnections()

    req, err := http.NewRequest(&amp;quot;GET&amp;quot;, selector.Url, nil)
    if err != nil {
        return nil, err
    }

    req.Header.Add(&amp;quot;User-Agent&amp;quot;, defaultUserAgent)

    res, err := httpClient().Do(req)
    if err != nil {
        return nil, err
    }
    return goquery.NewDocumentFromResponse(res)
}

func UseMaxConnections(max int) {
    semaphoreMaxConnections = make(chan struct{}, max)
}

func lockLimitConnections() {
    semaphoreMaxConnections &amp;lt;- struct{}{}
}
func unlockLimitConnections() {
    &amp;lt;-semaphoreMaxConnections
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the end It was a really fun, doing what it looks like a tedious job. And I get a clean JSON document when there is not any API available to use.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Error handling and pointers in Go lang</title>
      <link>http://dahernan.github.io/2014/06/22/error-handling-and-pointers-in-go-lang/</link>
      <pubDate>Sun, 22 Jun 2014 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2014/06/22/error-handling-and-pointers-in-go-lang/</guid>
      <description>&lt;p&gt;A couple of weeks ago I went to the &lt;a href=&#34;http://www.meetup.com/Go-London-User-Group/&#34;&gt;Go London User Group&lt;/a&gt; and one of the talks was about &lt;a href=&#34;https://www.youtube.com/watch?v=Ph4eYD7Bgek&#34;&gt;error handling in Go&lt;/a&gt; by Daniel Morsing (really good talk).&lt;/p&gt;

&lt;p&gt;After thinking, I rembembered that there is another antipattern when using pointers to error, for example here.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// http://play.golang.org/p/Xktu2Jz-Zc

package main

import &amp;quot;fmt&amp;quot;

type MyError struct {
    path string
    msg  string
}

func (e MyError) Error() string {
    return e.path + &amp;quot;:&amp;quot; + e.msg
}

func uglyBug(blowup bool) error {
    var err *MyError = nil
    if blowup {
        err = &amp;amp;MyError{&amp;quot;path1&amp;quot;, &amp;quot;msg1&amp;quot;}
    }
    return err
}

func main() {
    e1 := uglyBug(false)
    if e1 != nil {
        fmt.Println(&amp;quot;Pointer -&amp;gt; &amp;quot;, e1)
    } else {
        fmt.Println(&amp;quot;It&#39;s ok&amp;quot;)
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:
&lt;code&gt;
Pointer -&amp;gt;  &amp;lt;nil&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The value of &lt;em&gt;e1&lt;/em&gt; is going to be &lt;em&gt;not nil&lt;/em&gt;, because the interface is not nil (it needs to have the value and the type nil, to return nil).&lt;/p&gt;

&lt;p&gt;To fix this, you have to explicit return nil.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

type MyError struct {
    path string
    msg  string
}

func (e MyError) Error() string {
    return e.path + &amp;quot;:&amp;quot; + e.msg
}

func fixed(blowup bool) error {
    if blowup {
        return &amp;amp;MyError{&amp;quot;path1&amp;quot;, &amp;quot;msg1&amp;quot;}
    }
    return nil
}

func main() {
    e1 := fixed(false)
    if e1 != nil {
        fmt.Println(&amp;quot;Pointer -&amp;gt; &amp;quot;, e1)
    } else {
        fmt.Println(&amp;quot;It&#39;s ok&amp;quot;)
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:
&lt;code&gt;
It&#39;s ok
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So always do a explicit return nil, when you need an interface to be nil.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Compile and reload your package in Go lang</title>
      <link>http://dahernan.github.io/2013/08/03/compile-and-reload-your-package-in-go-lang/</link>
      <pubDate>Sat, 03 Aug 2013 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2013/08/03/compile-and-reload-your-package-in-go-lang/</guid>
      <description>&lt;p&gt;One of the Go lang goodness is the blazing fast compiler (can you hear me Scala? :P), that can give you the productivity of a interpreted language.
But to be, productive in the same way, at least building Web services, you need get rid of the recompile and kill/reload cycle for your application.&lt;/p&gt;

&lt;p&gt;I tried a couple of utils to do that, and the most simple that it works is &lt;a href=&#34;https://github.com/skelterjohn/rerun&#34;&gt;&lt;em&gt;rerun&lt;/em&gt;&lt;/a&gt;
You can just clone the repository, do a &amp;lsquo;go install&amp;rsquo; and add the binary to your PATH variable.&lt;/p&gt;

&lt;p&gt;And now with a simple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rerun --test github.com/dahernan/goangular/server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have my webserver running, and every time that I make a change in the code, the test are passed again, and the server is reload. I know, right now my server It&amp;rsquo;s very light and It does that in milliseconds, but I&amp;rsquo;m sure it&amp;rsquo;s not going to reach the start time of any Java application :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Json service in Go lang</title>
      <link>http://dahernan.github.io/2013/06/21/json-service-in-go-lang/</link>
      <pubDate>Fri, 21 Jun 2013 00:00:00 UTC</pubDate>
      <author>Enthusiastic Hugo User</author>
      <guid>http://dahernan.github.io/2013/06/21/json-service-in-go-lang/</guid>
      <description>&lt;p&gt;These days I&amp;rsquo;m experimenting with Go lang, I love the language. I like specially the simplicity, you can check out
the principles of design, in the presentation from Rob Pike, &lt;a href=&#34;http://www.stanford.edu/class/ee380/Abstracts/100428-pike-stanford.pdf&#34;&gt;Another Go At Language Design&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So, my first try in Go is to do a small Rest API for serving JSON documents. Also try a little TDD in Go to see how easy it could be.&lt;/p&gt;

&lt;p&gt;On the test it&amp;rsquo;s easy to mock whatever you need, because function are first class citizens,
so you can have implementations on fly. And some of the clasess of the standard library they have test utilities like &amp;lsquo;httptest&amp;rsquo;&lt;/p&gt;

&lt;p&gt;Here the test.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
  &amp;quot;github.com/bmizerany/assert&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;net/http/httptest&amp;quot;
    &amp;quot;testing&amp;quot;
)

func TestJsonServerReturnsJsonDocumentWithRightHeaders(t *testing.T) {

    req := new(http.Request)

    builder := func(req *http.Request) interface{} {
        return map[string]interface{}{
            &amp;quot;test&amp;quot;: &amp;quot;test_value&amp;quot;,
        }
    }

    jsonServer := JsonServer(builder)
    responseWriter := httptest.NewRecorder()

    // call to test
    jsonServer(responseWriter, req)

    contentType := responseWriter.Header().Get(&amp;quot;Content-Type&amp;quot;)
    assert.Equal(t, contentType, &amp;quot;application/json&amp;quot;)

    assert.Equal(t, &amp;quot;{\&amp;quot;test\&amp;quot;:\&amp;quot;test_value\&amp;quot;}\n&amp;quot;, responseWriter.Body.String())

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now the implementation, with a little functional style.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;package main

import (
  &amp;quot;encoding/json&amp;quot;
  &amp;quot;github.com/bmizerany/pat&amp;quot;
  &amp;quot;log&amp;quot;
    &amp;quot;net/http&amp;quot;
)

type httpHandlerFunc func(w http.ResponseWriter, req *http.Request)
type jsonHttpBuilderFunc func(req *http.Request) interface{}

func JsonBuilder(req *http.Request) interface{} {
    jsonMap := make(map[string]interface{})
    name := req.URL.Query().Get(&amp;quot;:name&amp;quot;)
    jsonMap[&amp;quot;message&amp;quot;] = &amp;quot;hello &amp;quot; + name
    return jsonMap
}

func JsonServer(builderFunc jsonHttpBuilderFunc) (hanlderFunc httpHandlerFunc) {
    hanlderFunc = func(w http.ResponseWriter, req *http.Request) {
        enc := json.NewEncoder(w)
        jsonMap := builderFunc(req)
        w.Header().Set(&amp;quot;Content-Type&amp;quot;, &amp;quot;application/json&amp;quot;)
        if err := enc.Encode(&amp;amp;jsonMap); err != nil {
            log.Fatal(err)
        }
    }
    return
}

func main() {
    m := pat.New()
    m.Get(&amp;quot;/api/hello/:name&amp;quot;, http.HandlerFunc(JsonServer(JsonBuilder)))

    http.Handle(&amp;quot;/&amp;quot;, m)
    err := http.ListenAndServe(&amp;quot;:3000&amp;quot;, nil)
    if err != nil {
        log.Fatal(&amp;quot;ListenAndServe: &amp;quot;, err)
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>